## 내부 클래스

내부 클래스(inner class)는 말 그대로 '클래스 내부에 선언한 클래스'이다. 내부에 선언하는 이유는 대개 이 클래스와 외부 클래스가 밀접한 관련이 있어서이다.
또한 그 밖의 다른 클래스와 협력할 일이 없는 경우에 내부 클래스로 선언해서 사용한다.

```java
class Out {
    class In {
    }
}
```

내부 클래스의 선언은 위와 같이 클래스 안에 클래스를 선언하는 것이다. 내부 클래스는 선언하는 위치나 예약어에 따라 네 가지 유형이 있다.

- 인스턴스 내부 클래스
- 정적 내부 클래스
- 지역 내부 클래스
- 익명 클래스

```java
class ABC {                   // 외부 클래스
    class In {                // 인스턴스 내부 클래스
        static class SIn      // 정적 내부 클래스
    }
    
    public void abc() {
        class Local {}        // 지역 내부 클래스
    }
}
```

### 인스턴스 내부 클래스

인스턴스 내부 클래스(instance inner class)는 인스턴스 변수를 선언할 때와 같은 위치에 선언하며, 외부 클래스 내부에서만 생성하여 사용하는 객체를 선언할 때 쓴다. 예를 들어 어떤 클래스 내에
여러 변수가 있고 이들 변수 중 일부를 모아 클래스로 표현하는 것이다. 이 클래스를 다른 외부 클래스에서 사용할 일이 없는 경우 내부 인스턴스 클래스로 정의하낟.
인스턴스 내부 클래스는 외부 클래스 생성 후 생성된다. 따라서 외부 클래스를 먼저 생성하지 않고 인스턴스 내부 클래스를 사용할 수 없다.

```java
class OutClass {
    private int num = 10;
    private static int sNum = 20;
    
    private InClass inClass;
    
    public OutClass() {
        inClass = new InClass();
    }
    
    class InClass {
        int inNum = 100;
        // static int sInNum = 200;
        
        void inTest() {
            System.out.prinln(num);
            System.out.prinln(sNum);
        }
        
        // static void sTest() // 정적 메서드 정의 불가
        
        public void usingClass() {
            inClass.inTest();
        }
    }
}

public class InnerTest {
    public static void main(String[] args) {
        OutClass outClass = new OutClass();
        outClass.usingClass(); // 외부 클래스에서 내부 클래스 기능 호출
    }
}
```

외부 클래스에서 선언한 변수들은 private지만 내부 클래스도 다 접근 가능하다. 내부 클래스에서 정적 변수와 메서드는 선언할 수 없다.
즉 인스턴스 내부 클래스는 외부 클래스가 먼저 생성되어야 사용할 수 있고 인스턴스 내부 클래스의 메서드는 외부 클래스의 메서드가 호출될 때 사용할 수 있다.
내부 클래스를 생성하는 이유는 그 클래스를 감싸고 있는 외부 클래스에서만 사용하기 위해서이다. 그렇지만 다른 클래스에서 private이 아닌 내부 클래스를 생성하는 것이 가능은 하다.

```java
OutClass outClass = new OutClass();
OutClass.InClass inClass = outClass.new InClass();
```

### 정적 내부 클래스

인스턴스 내부 클래스는 외부 클래스가 먼저 생성되어야 생성할 수 있기에 정적 변수와 메서드는 사용할 수 없다. 그런데 내부 클래스가 외부 클래스 생성과 무관하게 사용할 수 있어야 하고
정적 변수도 사용할 수 있어야 한다면 정적 내부 클래스(static inner class)를 사용하면 된다. 정적 내부 클래스는 인스턴스 내부 클래스처럼 외부 클래스의 멤버 변수와 같은 위치에 정의하며
static 예약어를 함께 사용한다.

```java
class OutClass {
    private int num = 10;
    private static int sNum = 20;
    
    static class InStaticClass {
        int inNum = 100;
        static int sInNum = 200;
    }
    
    void inTest() {
        // num += 10; // 외부 클래스의 인스턴스 변수는 사용할 수 없음.
        System.out.println(inNum);
        System.out.println(sInNum);
        System.out.println(sNum);
    }
    
    static void sTest() {
        // num += 10;
        // inNum += 10; // 외부 클래스와 내부 클래스의 인스턴스 변수는 사용할 수 없음
        System.out.println(sNum);
        System.out.println(sInNum);
    }
}

public class InnerTest {
    public static void main(String[] argS) {
        OutClass.InStaticClass sInClass = new OutClass.InStaticClass();
        sInClass.inTest();
        OutClass.InStaticClass.sTest();
    }
}
```

### 지역 내부 클래스

지역 내부 클래스는 지역 변수처럼 메서드 내부에 클래스를 정의하여 사용하는 것을 말한다. 그렇기에 이 클래스는 메서드 안에서만 사용할 수 있다.

```java
class Outer {
    int outNum = 100;
    static int sNum = 200;
    
    Runnable getRunnable(int i) {
        int num = 100;
        
        class MyRunnable implements Runnable {
            int localNum = 10;
            
            @Override
            public void run() {
                // num = 200; // 지역 변수는 상수로 바뀌므로 값을 변경할 수 없어 오류 발생
                // i = 100; // 매개변수도 지역 변수처럼 상수로 바뀌어 값을 변경할 수 없어 오류 발생
                System.out.println(i);
                System.out.println(num);
                System.out.println(localNum);
                System.out.println(outNum);
                System.out.println(Outter.sNu);
            }
        }
        return new MyRunnable();
    }
}

public class LocalInnerTest {
    public static void main(String[] args) {
        Outter out = new Outter();
        Runnable runner = out.getRunnable(10);
        runner.run();
    }
}
```

지역 내부 클래스에서 지역 변수의 유효성을 봐보자. 지역 변수는 메서드가 호출될 때 스택 메모리에 생성되고 메서드의 수행이 끝나면 메모리에서 사라진다. 그런데 지역 내부 클래스에 포함된 getRunnable() 메서드의 매개변수 i와 메서드 내부에 선언한 변수 num은 지역 변수이다. 그런데도 run()메서드가 정상적으로 호출된다. 이는 getRunnable() 메서드 호출이 끝나고 스택 메모리에서
지워진 변수를 이후에 또 참조할 수 있다는 것이다. 즉 지역 내부 클래스에서 사용하는 지역 변수는 상수로 처리된다. 이는 컴파일에서 final이 추가되어서 처리된다.

### 익명 내부 클래스

익명 내부 클래스는 이름을 사용하지 않는 클래스이다.

```java
class Outter2 {
    Runnable getRunnable(int i) {
        int num = 100;
        
        return new Runnable() {
            @Override
            public void run() {
                System.out.println(i)
                System.out.println(num)
            }
        }; // 클래스 끝에 ; 사용
    }
    
    Runnable runner = new Runnable() {
        @Override
        public void run() {
            System.out.println("Runnable이 구현된 익명 클래스 변수")
        }
    }; // 마찬가지로 ; 사용
}

public class AnonymousInnerTest {
    public static void main(String[] args) {
        Outter2 out = new Outter2();
        Runnable runnable = out.getRunnable(10);
        runnerable.run();
        out.runner.run();
    }
}
```

|종류|구현위치|사용할 수 있는 외부 클래스 변수|생성 방법|
|---|--------|----------------------------|---------|
|인스턴스 내부 클래스|외부 클래스 멤버 변수와 동일|외부 인스턴스 변수 외부 전역 변수|외부 클래스를 먼저 만든 후 내부 클래스 생성|
|정적 내부 클래스|외부 클래스 멤버 변수와 동일|외부 전역 변수|외부 클래스와 무관하게 생성|
|지역 내부 클래스|메서드 내부에 구현|외부 인스턴스 변수 외부 전역 변수|메서드를 호출할 때 생성|
|익명 내부 클래스|메서드 내부에 구현 변수에 대입하여 직접 구현|외부 인스턴스 변수 외부 전역 변수|메서드를 호출할 때 생성되거나, 인터페이스 타입 변수에 대입할 때 new 예약어를 사용하여 생성|

## 람다식

자바는 객체를 기반으로 프로그램을 만든다. 만약 어떤 기능이 필요하다면 클래스를 먼저 만들고, 클래스 안에 기능을 구현한 메서드를 만든 후 그 메서드를 호출해야 한다. 다시 말해 클래스가
없다면 메서드를 사용할 수 없다. 그런데 프로그래밍 언어 중에 함수의 구현과 호출만으로 프로그램을 만들 수 있는 프로그램 방식이 있다. 이를 `함수형 프로그래밍(Functional Programming; FP)`라고 한다. 자바는 8버전부터 이를 지원하고 있다. 자바에서 제공하는 함수형 프로그래밍 방식을 `람다식(Lambda expression)`이라고 한다.
람다식은 함수 이름이 없는 익명 함수를 만드는 것이다. 람다식의 문법은 다음과 같다.
> (매개변수) -> {실행문;}
```java
// 기존
int add(int x, int y) {
    return x + y;
}

// 람다식
(int x, int y) -> {return x + y};
```
