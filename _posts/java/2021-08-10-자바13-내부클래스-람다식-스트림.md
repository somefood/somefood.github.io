## 내부 클래스

내부 클래스(inner class)는 말 그대로 '클래스 내부에 선언한 클래스'이다. 내부에 선언하는 이유는 대개 이 클래스와 외부 클래스가 밀접한 관련이 있어서이다.
또한 그 밖의 다른 클래스와 협력할 일이 없는 경우에 내부 클래스로 선언해서 사용한다.

```java
class Out {
    class In {
    }
}
```

내부 클래스의 선언은 위와 같이 클래스 안에 클래스를 선언하는 것이다. 내부 클래스는 선언하는 위치나 예약어에 따라 네 가지 유형이 있다.

- 인스턴스 내부 클래스
- 정적 내부 클래스
- 지역 내부 클래스
- 익명 클래스

```java
class ABC {                   // 외부 클래스
    class In {                // 인스턴스 내부 클래스
        static class SIn      // 정적 내부 클래스
    }
    
    public void abc() {
        class Local {}        // 지역 내부 클래스
    }
}
```

### 인스턴스 내부 클래스

인스턴스 내부 클래스(instance inner class)는 인스턴스 변수를 선언할 때와 같은 위치에 선언하며, 외부 클래스 내부에서만 생성하여 사용하는 객체를 선언할 때 쓴다. 예를 들어 어떤 클래스 내에
여러 변수가 있고 이들 변수 중 일부를 모아 클래스로 표현하는 것이다. 이 클래스를 다른 외부 클래스에서 사용할 일이 없는 경우 내부 인스턴스 클래스로 정의하낟.
인스턴스 내부 클래스는 외부 클래스 생성 후 생성된다. 따라서 외부 클래스를 먼저 생성하지 않고 인스턴스 내부 클래스를 사용할 수 없다.

```java
class OutClass {
    private int num = 10;
    private static int sNum = 20;
    
    private InClass inClass;
    
    public OutClass() {
        inClass = new InClass();
    }
    
    class InClass {
        int inNum = 100;
        // static int sInNum = 200;
        
        void inTest() {
            System.out.prinln(num);
            System.out.prinln(sNum);
        }
        
        // static void sTest() // 정적 메서드 정의 불가
        
        public void usingClass() {
            inClass.inTest();
        }
    }
}

public class InnerTest {
    public static void main(String[] args) {
        OutClass outClass = new OutClass();
        outClass.usingClass(); // 외부 클래스에서 내부 클래스 기능 호출
    }
}
```

외부 클래스에서 선언한 변수들은 private지만 내부 클래스도 다 접근 가능하다. 내부 클래스에서 정적 변수와 메서드는 선언할 수 없다.
즉 인스턴스 내부 클래스는 외부 클래스가 먼저 생성되어야 사용할 수 있고 인스턴스 내부 클래스의 메서드는 외부 클래스의 메서드가 호출될 때 사용할 수 있다.
내부 클래스를 생성하는 이유는 그 클래스를 감싸고 있는 외부 클래스에서만 사용하기 위해서이다. 그렇지만 다른 클래스에서 private이 아닌 내부 클래스를 생성하는 것이 가능은 하다.

```java
OutClass outClass = new OutClass();
OutClass.InClass inClass = outClass.new InClass();
```

### 정적 내부 클래스

인스턴스 내부 클래스는 외부 클래스가 먼저 생성되어야 생성할 수 있기에 정적 변수와 메서드는 사용할 수 없다. 그런데 내부 클래스가 외부 클래스 생성과 무관하게 사용할 수 있어야 하고
정적 변수도 사용할 수 있어야 한다면 정적 내부 클래스(static inner class)를 사용하면 된다. 정적 내부 클래스는 인스턴스 내부 클래스처럼 외부 클래스의 멤버 변수와 같은 위치에 정의하며
static 예약어를 함께 사용한다.

```java
class OutClass {
    private int num = 10;
    private static int sNum = 20;
    
    static class InStaticClass {
        int inNum = 100;
        static int sInNum = 200;
    }
    
    void inTest() {
        // num += 10; // 외부 클래스의 인스턴스 변수는 사용할 수 없음.
        System.out.println(inNum);
        System.out.println(sInNum);
        System.out.println(sNum);
    }
    
    static void sTest() {
        // num += 10;
        // inNum += 10; // 외부 클래스와 내부 클래스의 인스턴스 변수는 사용할 수 없음
        System.out.println(sNum);
        System.out.println(sInNum);
    }
}

public class InnerTest {
    public static void main(String[] argS) {
        OutClass.InStaticClass sInClass = new OutClass.InStaticClass();
        sInClass.inTest();
        OutClass.InStaticClass.sTest();
    }
}
```

### 지역 내부 클래스

지역 내부 클래스는 지역 변수처럼 메서드 내부에 클래스를 정의하여 사용하는 것을 말한다. 그렇기에 이 클래스는 메서드 안에서만 사용할 수 있다.

```java
class Outer {
    int outNum = 100;
    static int sNum = 200;
    
    Runnable getRunnable(int i) {
        int num = 100;
        
        class MyRunnable implements Runnable {
            int localNum = 10;
            
            @Override
            public void run() {
                // num = 200; // 지역 변수는 상수로 바뀌므로 값을 변경할 수 없어 오류 발생
                // i = 100; // 매개변수도 지역 변수처럼 상수로 바뀌어 값을 변경할 수 없어 오류 발생
                System.out.println(i);
                System.out.println(num);
                System.out.println(localNum);
                System.out.println(outNum);
                System.out.println(Outter.sNu);
            }
        }
        return new MyRunnable();
    }
}

public class LocalInnerTest {
    public static void main(String[] args) {
        Outter out = new Outter();
        Runnable runner = out.getRunnable(10);
        runner.run();
    }
}
```

지역 내부 클래스에서 지역 변수의 유효성을 봐보자. 지역 변수는 메서드가 호출될 때 스택 메모리에 생성되고 메서드의 수행이 끝나면 메모리에서 사라진다. 그런데 지역 내부 클래스에 포함된 getRunnable() 메서드의 매개변수 i와 메서드 내부에 선언한 변수 num은 지역 변수이다. 그런데도 run()메서드가 정상적으로 호출된다. 이는 getRunnable() 메서드 호출이 끝나고 스택 메모리에서
지워진 변수를 이후에 또 참조할 수 있다는 것이다. 즉 지역 내부 클래스에서 사용하는 지역 변수는 상수로 처리된다. 이는 컴파일에서 final이 추가되어서 처리된다.

### 익명 내부 클래스

익명 내부 클래스는 이름을 사용하지 않는 클래스이다.

```java
class Outter2 {
    Runnable getRunnable(int i) {
        int num = 100;
        
        return new Runnable() {
            @Override
            public void run() {
                System.out.println(i)
                System.out.println(num)
            }
        }; // 클래스 끝에 ; 사용
    }
    
    Runnable runner = new Runnable() {
        @Override
        public void run() {
            System.out.println("Runnable이 구현된 익명 클래스 변수")
        }
    }; // 마찬가지로 ; 사용
}

public class AnonymousInnerTest {
    public static void main(String[] args) {
        Outter2 out = new Outter2();
        Runnable runnable = out.getRunnable(10);
        runnerable.run();
        out.runner.run();
    }
}
```

|종류|구현위치|사용할 수 있는 외부 클래스 변수|생성 방법|
|---|--------|----------------------------|---------|
|인스턴스 내부 클래스|외부 클래스 멤버 변수와 동일|외부 인스턴스 변수 외부 전역 변수|외부 클래스를 먼저 만든 후 내부 클래스 생성|
|정적 내부 클래스|외부 클래스 멤버 변수와 동일|외부 전역 변수|외부 클래스와 무관하게 생성|
|지역 내부 클래스|메서드 내부에 구현|외부 인스턴스 변수 외부 전역 변수|메서드를 호출할 때 생성|
|익명 내부 클래스|메서드 내부에 구현 변수에 대입하여 직접 구현|외부 인스턴스 변수 외부 전역 변수|메서드를 호출할 때 생성되거나, 인터페이스 타입 변수에 대입할 때 new 예약어를 사용하여 생성|

## 람다식

자바는 객체를 기반으로 프로그램을 만든다. 만약 어떤 기능이 필요하다면 클래스를 먼저 만들고, 클래스 안에 기능을 구현한 메서드를 만든 후 그 메서드를 호출해야 한다. 다시 말해 클래스가
없다면 메서드를 사용할 수 없다. 그런데 프로그래밍 언어 중에 함수의 구현과 호출만으로 프로그램을 만들 수 있는 프로그램 방식이 있다. 이를 `함수형 프로그래밍(Functional Programming; FP)`라고 한다. 자바는 8버전부터 이를 지원하고 있다. 자바에서 제공하는 함수형 프로그래밍 방식을 `람다식(Lambda expression)`이라고 한다.
람다식은 함수 이름이 없는 익명 함수를 만드는 것이다. 람다식의 문법은 다음과 같다.
> (매개변수) -> {실행문;}
```java
// 기존
int add(int x, int y) {
    return x + y;
}

// 람다식
(int x, int y) -> {return x + y};
```

이 외에도 여러 가지로 표현할 수 있다.

```java
// 매개변수 자료형 생략. 매개변수가 하나인 경우네는 괄호도 생략가능하다
str -> {System.out.println(str);}

// 이런식으로는 안된다.
x, y -> {System.out.println(x+y);

// 중괄호 안의 구현 부분이 한 문장인 경우 중괄호 생략
str -> System.out.println(str);

// 중괄호 안의 구현 부분이 한 문장이더라도 return문은 중괄호를 생략할 수 없다.
str -> return str.length();

// return 생략하기, 중괄호 안의 구현 부분이 return문 하나라면 중괄호와 return을 모두 생략하고 식만 쓴다.
(x, y) -> x + y
str -> str.length()
```

### 람다식 사용

두 수 중 큰 수를 찾는 함수를 람다식으로 구현해보겠다. 람다식을 구현하기 위해서는 먼저 인터페이스를 만들고, 인터페이스에 람다식으로 구현할 메서드를 선언한다. 이를 함수형 인터페이스라고 한다.

```java
public interface MyNumber {
    int getMax(int num1, int num2); // 추상 메서드 선언
}

public class TestMyNumber {
    public static void main(String[] args) {
        MyNumber max = (x, y) -> (x >= y) ? x : y; // 람다식으로 표현
        System.out.println(max.getMax(10, 20));
    }
}
```

함수형 프로그래밍은 순수 함수(pure function)을 구현하고 호출함으로써 외부 자료에 부수적인 영향(side effect)를 주지 않도록 구현하는 방식이다. 순수 함수란 매개변수만을 사용하여 만드는 함수이다. 즉 함수 내부에서 함수 외부에 있는 변수를 사용하지 않아 함수가 수행되더라도 외부에 영향을 주지 않는다.
객체 지향 언어가 객체를 기반으로 구현하는 방식이라면 함수형 프로그램은 함수를 기반으로 하고, 자료를 입력받아 구현하는 방식이다. 함수가 입력받은 자료 이외에 외부 자료에 영향을 미치지 않기 때문에 여러 자료 동시에 처리하는 병렬 처리에 적합하며, 안정되고 확장성 있는 프로그램을 개발할 수 있는 장점이 있다. 또 순수 함수로 구현된 함수형 프로그램은 함수 기능이 자료에 독립적일 수 있도록 보장해준다. 즉 동일한 입력에 대해서는 동일한 출력을 보장하고, 다양한 자료에 같은 기능을 수행할 수 있다.

### 함수형 인터페이스

람다식은 메서드 이름이 없고 메서드를 실행하는 데 필요한 매개변수와 매개변수를 활용한 실행 코드를 구현하는 것이다. 그렇다면 메서드는 어디에 선언하고 구현해야 할까. 함수형 언어에서는 함수만 따로 호출할 수 있지만, 자바에서는 참조 변수 없이 메서드를 호출할 수 없다. 그렇기에 람다식을 구현하기 위해 함수형 인터페이스를 만들고, 인터페이스에 람다식으로 구현할 메서드를 선언하는 것이다. 람다식은 하나의 메서드를 구현하여 인터페이스형 변수에 대입하므로 인터페이스가 두 개 이상의 메서드를 가지면 안된다.

```java
public interface MyNumber {
    int getMax(int num1, int num2);
    int add(int num1, int num2);
}
```

이런식으로 인터페이스에 여러 메서드가 있다면 어떤 메서드를 구현할 것인지 모호해진다. 그렇기에 람다식은 오직 하나의 메서드만 선언한 인터페이스를 구현할 수 있다.
위처럼 실수로 다른 메서드를 추가함을 방지하기 위해 `@FunctionalInterface`라는 어노테이션을 제공한다. 클래스 위에 위 어노테이션을 달면 메서드가 두 개 이상 발생시 오류가 발생한다.
필수는 아니지만 명시적으로 표시해주면 좋다.

```java
@FunctionalInterface
public interface MyNumber {
    int getMax(int num1, int num2);
    int add(int num1, int num2); // 오류 발생
}
```

### 객체 지향 프로그래밍 방식과 람다식 비교

문자열 두 개를 연결해서 출력하는 예제를 기존 객체 지향 방식과 람다식으로 구현해 보겠다. 람다식을 사용하면 기존 방식보다 간결한 코드를 구현할 수 있다.
메서드의 구현부를 클래스에 만들고, 이를 다시 인스턴스로 생성하고 호출하는 코드가 줄어들기 때문이다.

```java
public interface StringConcat {
    public void makeString(String s1, String s2);
}
```

이 인터페이스는 문자열 두 개를 매개변수로 입력받아 두 문자열을 연결하여 출력하는 메서드를 가지고 있다. Hello, World 이런식으로 합쳐질 것이다.

```java
// 기존 객체지향
public class StringConCatImpl implements StringConcat {
    @Override
    public void makeString(String s1, String s2) {
        System.out.println(s1 + ", " + s2);
    }
}

// 람다식
public class TestStringConcat {
    public static void main(String[] args) {
        String s1 = "Hello";
        String s2 = "World";
        StringConCatImpl concat1 = new StringConCatImpl();
        concat1.makeString(s1, s2);
        StringConcat concat2 = (s, v) -> System.out.println(s + ", " + v);
        concat2.makeString(s1, s2);
    }
}
```

### 익명 객체를 생성하는 람다식

자바는 객체 지향 언어이다. 그런데 람다식은 객체 없이 인터페이스의 구현만으로 메서드를 호출할 수 있었다. 어떻게 생성없이 메서드 호출이 가능했을까. 우리는 앞에서 익명 내부 클래스에 대해 배웠다. 익명 내부 클래스는 클래스 이름 없이 인터페이스 자료형 변수에 바로 메서드 구현부를 생성하여 대입할 수 있다. 즉 람다식으로 메서드를 구현해서 호출하면 컴퓨터 내부에서는 다음처럼 익명 클래스가 생성되고 이를 통해 익명 객체가 생성되는 것이다.

```java
StringConcat concat3 = new StringConcat() {
    @Override
    public void makeString(String s1, String s2) {
        System.out.println(s1 + ", " + s2);
    }
};
```

**람다식에서 사용하는 지역 변수**
두 문자열을 연결하는 람다식 코드에서 외부 메서드의 지역 변수인 i를 수정하면 어떻게 될까

```java
public class TestStringConcat {
    public static void main(String[] args) {
        int i = 100;
        
        StringConcat concat2 = (s, v) -> {
            // i = 200; // 람다식 내부에서 변경하면 오류 발생         
        };
    }
}
```

위 주석 부분이 에러가 나타날 것인데, 이는 지역 내부 클래스에서 다루었던 내용과 같다. 지역 변수는 메서드 호출이 끝나면 메모리에서 사라지기 때문에 익명 내부 클래스에서 사용하는 경우에는
지역 변수가 상수로 변한다. 람다식 역시 익명 내부 클래스가 생성되므로 외부 메서드의 지역 변수를 사용하면 변수는 final 변수, 즉 상수가 되기에 이 변수를 변경하면 오류가 발생한다.

### 함수를 변수처럼 사용하는 람다식

람다식을 이용하면 구현된 함수를 변수처럼 사용할 수 있다. 우리가 프로그램에서 변수를 사용하는 경우는 크게 세 가지이다.
1. 특정 자료형으로 변수 선언 후 값 대입하여 사용하기. int a = 10;
2. 매개변수로 전달하기. int add(int x, int y);
3. 메서드의 반환 값으로 반환하기. return num;

람다식으로 구현된 메서드도 변수에 대입하여 사용할 수 있고, 매개변수로 전달하고 반환할 수 있다.

- 인터페이스형 변수에 람다식 대입하기

인터페이스형 변수에 람다식을 대입하는 방법은 위에서 해보았다. 다음과 같이 함수형 인터페이스 PrintString이 있고, 여기에 메서드를 하나 선언한다. 이 메서드를 구현하면 다음과 같다.

```java
interface PrintString {
    void showString(String str);
}

PrintString lambdaStr = s -> System.out.println(s)
lambdaStr.showString("hello lambda");
```

- 매개변수로 전달하는 람다식

람다식을 변수에 대입하면 이를 매개변수로 전달할 수 있다. 이때 전달되는 매개변수의 자료형은 인터페이스형이다.

```java
interface PrintString {
    void showString(String str);
}

public class TestLambda {
    public static void main(String[] args) {
        PrintString lambdaStr = s -> System.out.println(s);
        lambdaStr.showString("hello lambda");
        showMyString(lambdaStr);
    }
    
    public static void showMyString(PrintString p) {
        p.showString("hello lambda2");
    }
}
```

- 반환 값으로 쓰이는 람다식

다음과 같이 메서드의 반환형을 람다식의 인터페이스형으로 선언하면 구현한 람다식을 반환할 수 있다.

```java
public static PrintString returnString() {
    PrintString str = s -> System.out.println(s + "world");
    return str;
}

// 또는

public static PrintString returnString() {
    return s -> System.out.println(s + "world");;
}

// 테스트
interface PrintString {
    void showString(String str);
}

public class TestLambda {
    public static void main(String[] args) {
        PrintString reStr = returnString();
        reStr.showString("hello ");
    }
    
    public static void showMyString(PrintString p) {
        p.showString("hello lambda2");
    }
    
    public static PrintString returnString() {
        return s -> System.out.println(s + "world");
    }
}
```
